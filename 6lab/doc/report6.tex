\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{minted}
\usepackage{color} %% это для отображения цвета в коде
\usepackage{listings}
\lstset{ %
	language=C++,                 % выбор языка для подсветки (здесь это С++)
	basicstyle=\footnotesize\sffamily, % размер и начертание шрифта для подсветки кода
	numbers=left,               % где поставить нумерацию строк (слева\справа)
	numberstyle=\tiny,           % размер шрифта для номеров строк
	stepnumber=1,                   % размер шага между двумя номерами строк
	numbersep=5pt,                % как далеко отстоят номера строк от подсвечиваемого кода
	backgroundcolor=\color{white}, % цвет фона подсветки - используем \usepackage{color}
	showspaces=false,            % показывать или нет пробелы специальными отступами
	showstringspaces=false,      % показывать или нет пробелы в строках
	showtabs=false,             % показывать или нет табуляцию в строках
	frame=single,              % рисовать рамку вокруг кода
	tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
	captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
	breaklines=true,           % автоматически переносить строки (да\нет)
	breakatwhitespace=false, % переносить строки только если есть пробел
	escapeinside={\%*}{*)}   % если нужно добавить комментарии в коде
}
\usepackage{alltt}
\usepackage{amsmath}
\usepackage{pgfplots}
\pgfplotsset{compat=1.9}

\begin{document}
	
	\section*{Лабораторная работа №\,6 по курсу дискретного анализа: Калькулятор}
	
	Выполнил студент группы М8О-308Б-20 \textit{Ядров Артем}.
	
	\subsection*{Условие}
	Необходимо разработать программную библиотеку на языке $C$ или
	$C++$, реализующую простейшие арифметические действия и проверку
	условий над целыми неотрицательными числами. На основании этой
	библиотеки, нужно составить программу, выполняющую вычисления
	над парами десятичных чисел и выводящую результат на стандартный
	файл вывода.
	
	Список арифметических операций:
	\begin{itemize}
		\item Сложение (+).
		\item Вычитание (-).
		\item Умножение (*).
		\item Возведение в степень (\^).
		\item Деление (/).
	\end{itemize}
	
	В случае возникновения переполнения в результате вычислений,
	попытки вычесть из меньшего числа большее, деления на ноль или
	возведении нуля в нулевую степень, программа должна вывести на
	экран строку $Error$.
	
	Список условий:
	\begin{itemize}
		\item Больше (>).
		\item Меньше (<).
		\item Равно (=).
		
		В случае выполнения условия, программа должна вывести на экран
		строку $true$, в противном случае — $false$.
	\end{itemize}
	\subsection*{Метод решения}
	\subsubsection*{Структура числа}
	Для того, чтобы хранить большие числа я решил использовать другую систему счисления: основание системы должно быть достаточно большим, но при этом необходима замкнутость относительно операции умножения "цифр" системы (при умножении во избежании переполнения типов результат должен оставаться в типе $int$). Удобнее всего было бы взять степень двойки для битовых операций, однако для удобства при считывании я принял решения в качестве основания взять число $10^4$.
	
	Длинное число хранится в виде вектора его цифр в порядке убывания разрядов (последний разряд хранится в начале, первый - в конце). Таким образом добавление разряда в начало числа не требует сдвига всего вектора, который можно выполнить за $O(n)$. Также несмотря на то, что в задаче мы оперируем с целыми неотрицательными числами, я добавил представление отрицательных чисел: для этого существует флаг, который отвечает за знак числа.
	\subsubsection*{Простые операции}
	Конструкторы класса $BigInt$ слишком примитивны, чтобы их описывать.  Для реализации сравнения достаточно было реализовать две операции: я выбрал операцию "меньше" и "равно". Операция равенства достаточно проста и требует проверки вектора и флага отрицательного числа на равенство, в то время как в операции "меньше" необходимо учесть случаи, когда числа имеют разные знаки.
	
	Далее идет реализация операций сложения и вычитания. Они выполняются известным школьным методом: в столбик. Необходимо учитывать перенос разрядов. В общем вся операция выполняется за $O(n)$, где $n$ - максимальное количество разрядов среди двух чисел.
	
	\subsubsection*{Умножение}
	Операцию умножения можно реализовать 3 способами: школьное умножение "столбиком"($O(n^3)$), метод Карацубы ($O(n^{\log_2 3})$) и с помощью дискретного преобразования Фурье($O(n\log n))$. Я выбрал третий способ, так как он самый быстрый и уже знакомый. Итак, преобразование Фурье. Известно, что любое $n$-значное число в $p$-ричной системе счисления можно записать в виде многочлена следующего вида:
	
	\begin{center}
		$A(p) = a_0p^0 + a_1p^1 + a_2 p^2 + \ldots + a_{n_1} p^{n-1} = \displaystyle \sum_{k = 0}^{n-1} a_k  p^k$
	\end{center}

	То есть каждому числу соответствует единственный многочлен и каждому многочлену соответствует единственное число. Но многочлены с многочленами можно оперировать в любом поле, результат не изменится.
	
	Любой многочлен можно представить в виде набора коэффициентов, при этом умножение в таком виде будет происходить за время $O(n^2)$, либо в виде $n$ различных точек, при этом умножение будет происходить за $O(n)$ путем умножения соответствующих точек. Дискретным преобразованием Фурье называется переход от представления в виде коэффициентов к представлению в виде набора точек. Обратным дискретным преобразованием Фурье называется переход от представления в виде набора точек к представлению в виде набора коэффициентов. Если существует алгоритм прямого и обратного преобразования, который эффективнее, чем $O(n^2)$, то можно перемножать многочлены путем прямого преобразования, перемножения точек и обратного преобразования за время, меньшее чем при наивном алгоритме. Оказывается, существует алгоритм быстрого преобразования Фурье (БПФ), названный в честь Кули и Таки. Его временная оценка $O(n\log n)$. Основывается алгоритм на хорошо известном методе "разделяй и властвуй". Основная идея состоит в выборе точек: в качестве точек берутся корни $n$-ой степени из единицы в комплексном поле. Известно, что все корни являются степенями числа $e^{\frac{2\pi i}{n}}$.
	
	Теперь приступим к преобразованию. Пусть имеется многочлен $A(x)$ степени $ \\ n = 2^k, (k > 0)$. В любом случае многочлен можно дополнить до степени двойки нулевыми коэффициентами.
	\begin{enumerate}
		\item Разделим многочлен на два: один - с четными коэффициентами, другой - с нечетными.
		
		$A_0 (x) = a_0x^0 + a_2x^1+a_4x^2 + \ldots + a_{n/2}x^{n/2 - 1}$
		
		$A_1 (x) = a_1x^0 + a_3x^1 + a_5x^2 + \ldots + a_{n/2}x^{n/2-1}$
		
		При этом $A(x) = A_0(x^2) + x A_1(x^2)$.
		\item Рекурсивно преобразуем многочлены $A_0$ и $A_1$.
		\item Пусть мы получили набор $\{y_k^0\}_{k = 0}^{n/2 -1}$ - преобразование многочлена $A_0$ и набор $\{y_k^1\}_{k = 0}^{n/2 -1}$ - преобразование многочлена $A_1$. Восстановим точки $y_k$ исходного многочлена.
		\begin{eqnarray*}
			& y_k = y_k^0 + \omega_n^k y_k^1 \qquad \forall k = 0, 1, \ldots, n/2 - 1 & \\
				& y_{k + n/2} = A(\omega_n^{k + n/2}) = A_0(\omega_n^{2k + n}) + \omega_n^{k + n/2} A_1(\omega_n^{2k+n})  = A_0(\omega_n^{2k} \omega_n^n) + \omega_n^k \omega_n^{n/2} A_1(\omega_n^{2k} \omega_n^n) = & \\
				& \qquad= A_0(\omega_n^{2k}) - \omega_n^k A_1(\omega_n^{2k}) = y_0^k - \omega_n^k y_1^k
		\end{eqnarray*}
	
	\end{enumerate}

	Итак, мы получили формулы для вычисления всего вектора $\{y_k\}$.
	
	Обратное преобразование Фурье почти не отличается от прямого: вместо $\omega_n^k$ необходимо использовать $\omega_n^{-k}$ и каждый элемент результата разделить на $n$.
	
	\subsubsection*{Возведение в степень}
	Очевидно, что возведение в степень прямым способ длинных чисел будет выполняться очень долго. К счастью, существует алгоритм, работающий более быстро: бинарное возведение в степень, который выполняет всего лишь $O(\log n)$ умножений.
	
	Заметим, что для любого числа $a$ и для любого четного числа $n$ выполняется следующее равенство:
	\begin{equation*}
		a^n = (a^{n/2})^2 = a^{n/2} \cdot a^{n/2}
	\end{equation*}
Оно и является основным в методе бинарного возведения в степень. Действительно, для чётного $n$ мы показали, как, потратив всего одну операцию умножения, можно свести задачу к вдвое меньшей степени.

Осталось понять, что делать, если степень $n$ нечётна. Здесь мы поступаем очень просто: перейдём к степени $n-1$, которая будет уже чётной:
\begin{equation*}
	a^n = a^{n-1} \cdot a
\end{equation*}
Итак, мы фактически нашли рекуррентную формулу: от степени $n$ мы переходим, если она чётна, к $n/2$, а иначе — к $n-1$. Понятно, что всего будет не более $2 \log n$ переходов, прежде чем мы придём к $n = 0$ (базе рекуррентной формулы). Таким образом, мы получили алгоритм, работающий за $O (\log n)$ умножений.

\subsubsection*{Деление}
Немного про деление: это тоже довольно неочевидная операция. Существует алгоритм деления путем вычисления обратного к делителю с точностью до $1/2$ путем нахождения нуля функции $f(x)$ методом Ньютона, где
\begin{equation*}
	f(x) = 1 - Bx
\end{equation*}
Далее делитель умножается на число, обратное делителю, и находится частное. Зная частное, всегда можно найти остаток от деления.

Однако я решил выбрать более простой метод и реализовал школьное деление "в столбик".
	\subsection*{Исходный код}
	Реализацию класса $BigInt$ я решил разбить на несколько файлов:
	\begin{enumerate}
		\item Файл с конструкторами ($Constructors.cpp$)
		\item Файл с операциями сравнения ($Predicates.cpp$)
		\item Файл с операциями сложения, вычитания, инкремента, декремента и прочими ($ArithmeticOperations.cpp$)
		\item Файл с операциями умножения, деления, сдвига ($BigInt.cpp$)
	\end{enumerate}
	Для преобразования Фурье я создал отдельный класс $Fourier$, содержащий два статических метода: преобразования Фурье и умножения полиномов.
	
	\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
	\inputminted[breaklines]{C++}{../src/Fourier.h}
	\vspace{5mm}
	\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
	\inputminted[breaklines]{C++}{../src/Fourier.cpp}
	\vspace{5mm}
	\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
	
	\inputminted[breaklines]{C++}{../src/BigInt.h}
	\vspace{5mm}
	\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
	
	\inputminted[breaklines]{C++}{../src/BigInt.cpp}
	\vspace{5mm}
	\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
	
	\inputminted[breaklines]{C++}{../src/Constructors.cpp}
	\vspace{5mm}
	\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
	
	\inputminted[breaklines]{C++}{../src/Predicates.cpp}
	\vspace{5mm}
	\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
	
		\inputminted[breaklines]{C++}{../src/ArithmeticOperations.cpp}
	\vspace{5mm}
	\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
	
	\inputminted[breaklines]{C++}{../src/main.cpp}
	\newpage
	\subsection*{Дневник отладки}
	Во время реализация я столкнулся с небольшими багами в программе, над устранением которых я долго ломал мозг. Приведу некоторые из них:
	\begin{itemize}
		\item Изначально в качестве основания системы счисления я взял число $10^9$. Переполнений было не избежать, как бы я не старался. В конечном итоге я выбрал число поменьше.
		\item При сложении долгое время плохо работал перенос разрядов в виду из-за моего неправильного алгоритма сложения.
		\item Перенос при вычитании тоже работал неправильно. Я добавлял к текущему разряду число, но забыл убирать его у предыдущего разряда.
		\item Операция сравнения могла работать неправильно из-за утечки памяти. При инициализации переменной итерирования я устанавливал значение, равное длине вектора. Правильным было значение длины вектора - 1.
	\end{itemize}

	\subsection*{Тест производительности}
	
	Протестируем работу моей программы на входных данных различной длинны. Возьмем основные операции: сложение (выполняется за $O(n)$), умножение (выполняется за $O(n\log n)$), возведение в степень (выполняется за $O(\log n)$, где $n$ - степень).
	В качестве $n$ возьмем следующие числа: 10, 25, 50, 75, 100. Для возведения степень основание степени возьмем равным число вида $999\ldots99$ размера 256.
	Операции сложения и  умножения замерялись группой по 100 операций. Поэтому неудивительно, что на графике операция умножения расположена выше операции возведения в степень
	
	\begin{tikzpicture}% coordinates
		\begin{axis}[
			xlabel=N,
			ylabel= T (msecs),
			ymin = 0,
			grid=major,
			legend pos=outer north east
			]
			\legend{Multiplication, Sum, Pow}
			\addplot coordinates {(10, 18) (25, 51) (50, 78) (75, 155) (100, 203)};
			\addplot coordinates {(10, 4) (25, 10) (50, 22) (75, 31) (100, 44)};
			\addplot coordinates {(10, 24) (25, 30) (50, 56) (75, 95) (100, 117)};
		\end{axis}
	\end{tikzpicture}
	\subsection*{Выводы}
	
	Длинная арифметика может применяться в криптографии. Большинство систем подписывания и шифрования данных используют целочисленную арифметику по модулю m, где m — очень большое натуральное число, не обязательно простое. Например, при реализации метода шифрования RSA, криптосистемы Рабина или схемы Эль-Гамаля требуется обеспечить точность результатов умножения и возведения в степень порядка $10^{309}$ (сам пока не сталкивался, но верю Википедии на слово).
	
	Я доволен, что смог реализовать не самую простую реализацию длинной арифметики(сумел оптимизировать умножение). Конечно, жаль, что я не смог реализовать быстрое деление, но всё же существующая реализация достаточно быстрая, поэтому не стоит отчаиваться. Надеюсь, данная библиотека поможет мне в будущем.
\end{document}
