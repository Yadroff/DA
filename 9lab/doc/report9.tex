\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{minted}
\usepackage{color} %% это для отображения цвета в коде
\usepackage{listings}
\lstset{ %
	language=C++,                 % выбор языка для подсветки (здесь это С++)
	basicstyle=\footnotesize\sffamily, % размер и начертание шрифта для подсветки кода
	numbers=left,               % где поставить нумерацию строк (слева\справа)
	numberstyle=\tiny,           % размер шрифта для номеров строк
	stepnumber=1,                   % размер шага между двумя номерами строк
	numbersep=5pt,                % как далеко отстоят номера строк от подсвечиваемого кода
	backgroundcolor=\color{white}, % цвет фона подсветки - используем \usepackage{color}
	showspaces=false,            % показывать или нет пробелы специальными отступами
	showstringspaces=false,      % показывать или нет пробелы в строках
	showtabs=false,             % показывать или нет табуляцию в строках
	frame=single,              % рисовать рамку вокруг кода
	tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
	captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
	breaklines=true,           % автоматически переносить строки (да\нет)
	breakatwhitespace=false, % переносить строки только если есть пробел
	escapeinside={\%*}{*)}   % если нужно добавить комментарии в коде
}
\usepackage{alltt}
\usepackage{amsmath}
\usepackage{pgfplots}
\pgfplotsset{compat=1.9}

\begin{document}
	
	\section*{Лабораторная работа №\,9 по курсу дискретного анализа: Графы}
	
	Выполнил студент группы М8О-308Б-20 \textit{Ядров Артем}.
	
	\subsection*{Условие}
	
	Реализовать программу на языке C или C++, соответствующую
	построенному алгоритму. Формат входных и выходных данных описан в
	варианте задания.
	
Задан неориентированный граф, состоящий из $n$ вершин и $m$ ребер. Вершины пронумерованы целыми числами от $1$ до $n$.
 Необходимо вывести все компоненты связности данного графа.
	
	\subsection*{Метод решения}
	
	Для данной задачи необходимо полностью обойти граф. Сделать это можно 2 способами: обходом в глубину или обходом в ширину. Я выбрал обход в ширину.
	
	Суть обхода в ширину заключается в последовательном обходе отдельных уровней графа, начиная с заданной вершины.
	
	 Рассматриваются все рёбра $(u, v), $ выходящие из вершины $u$. 
	Вершина $v$ добавляется в очередь.  После того, как будут проверены все рёбра, выходящие из вершины $u$, из очереди извлекается следующая вершина, процесс повторяется.
	
	Ключевая разница между обходом в глубину и в ширину заключается в порядке обхода: при поиске в глубину мы "углубляемся" в граф, а при поиске в ширину мы идём вширь.
	
	В ходе обхода будет посещена каждая вершина в компоненте и обход попробует пройти по каждому ребру. Поэтому сложность алгоритма составит $\mathcal{O}(|V| + |E|)$, где $V$ - множество вершин в компоненте связности, $E$ - множество ребер в компоненте.
	
	Если граф несвязный (имеется две и более компонент связности), то требуется выполнить обход в каждой компоненте. Пусть мы начали с какой-то компоненты. Тогда мы обошли все вершины в ней и все они были помечены нами. В таком случае какая-то вершина в другой компоненте осталась непомеченной. Начав обход заново обход  с непомеченной вершины, мы обойдем еще не пройденную компоненту. Таким образом будем продолжать, пока все вершины не будут пройдены.
	
	Независимо от того, сколько имеется компонент связности, итоговая сложность составит $\mathcal{O}(n + m)$ времени и $\mathcal{O}(n)$ памяти. Учитывая время на сортировку компонент, получим временную сложность $\mathcal{O}(n \cdot \log(n) + m)$.
	\subsection*{Исходный код}
	Для реализации обходов я использовал класс графа. Граф хранится в виде списка смежности.
	
	Для реализации обхода в глубину я использовал очередь и вектор типа $bool$ посещенных вершин. Ищем первый непосещенный элемент и кладем его в очередь. Пока очередь не пуста, вынимаем из очереди вершину и смотрим кладем в очередь и  компоненту (она представлена в виде вектора из вершин) все непосещенные вершины, которые соединены ребром с данной. После того, как очередь осталась пуста, кладем компоненту в ответ и запускаем тот же процесс.

	\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
	\inputminted[breaklines]{C++}{../src/Graph.h}
	\vspace{5mm}
	\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
	\inputminted[breaklines]{C++}{../src/Graph.cpp}
	\vspace{5mm}
	\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
	
	\inputminted[breaklines]{C++}{../src/main.cpp}
	\newpage
	\subsection*{Дневник отладки}
	Во время выполнения задачи я столкнулся с проблемой в виде ограничения по времени. Как выяснилось, я передавал в конструктор класса $Graph$ список смежности не по ссылке, а по значению, из-за чего происходило долгое копирование вектора.


	\subsection*{Тест производительности}
	
	Я решил сравнить обход в ширину, который я использовал, с рекурсивным обходом в глубину. Результаты оказались неожиданными, т.к. я предполагал, что выход из рекурсии будет занимать много времени, поэтому мой вариант будет работать быстрее.
	\begin{tikzpicture}% coordinates
		\begin{axis}[
			xlabel=N,
			ylabel= $\log(T) (msecs)$,
			ymin = 0,
			grid=major,
			legend pos = outer north east
			]
			\legend{BFS, DFS}
			\addplot coordinates {(5, 3.49650756154243) (10, 2.89037175795895) (100, 4.94164242271664) (1000, 10.4313472690845)};
			\addplot coordinates {(5, 1.38629436115) (10, 2.19722457738395) (100, 5.84643877518472) (1000, 10.4263504371391)};
		\end{axis}
	\end{tikzpicture}
	\subsection*{Выводы}
	
	
	В результате выполнения лабораторной работы я изучил способы представления графа в компьютере и базовые алгоритмы на графах: обход в ширину и в глубину.
	
	Мы сталкиваемся с графами каждый день, прокладывая маршрут от дома до института (поиск кратчайшего пути в графе), да даже в социальных сетях можно увидеть графы! Компоненты связности можно увидеть в графе друзей в небезызвестной социальной сети "В Контакте". Вершинами являются пользователи соц. сети, а ребрами соединены пользователи, состоящие в друзьях. Поэтому графы и связанные с ними задачи максимально близки к жизни и требуют эффективных алгоритмов решения задач.
\end{document}
