\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{minted}
\usepackage{color} %% это для отображения цвета в коде
\usepackage{listings}
\lstset{ %
	language=C++,                 % выбор языка для подсветки (здесь это С++)
	basicstyle=\footnotesize\sffamily, % размер и начертание шрифта для подсветки кода
	numbers=left,               % где поставить нумерацию строк (слева\справа)
	numberstyle=\tiny,           % размер шрифта для номеров строк
	stepnumber=1,                   % размер шага между двумя номерами строк
	numbersep=5pt,                % как далеко отстоят номера строк от подсвечиваемого кода
	backgroundcolor=\color{white}, % цвет фона подсветки - используем \usepackage{color}
	showspaces=false,            % показывать или нет пробелы специальными отступами
	showstringspaces=false,      % показывать или нет пробелы в строках
	showtabs=false,             % показывать или нет табуляцию в строках
	frame=single,              % рисовать рамку вокруг кода
	tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
	captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
	breaklines=true,           % автоматически переносить строки (да\нет)
	breakatwhitespace=false, % переносить строки только если есть пробел
	escapeinside={\%*}{*)}   % если нужно добавить комментарии в коде
}
\usepackage{alltt}
\usepackage{amsmath}
\usepackage{pgfplots}
\pgfplotsset{compat=1.9}
\begin{document}
	
	\section*{Лабораторная работа №\,5 по курсу дискретного анализа: Суффиксные деревья}
	
	Выполнил студент группы М8О-308Б-20 \textit{Ядров Артем}.
	
	\subsection*{Условие}
	
	Необходимо реализовать алгоритм Укконена построения суффиксного
	дерева за линейное время. Построив такое дерево для некоторых из
	входных строк, необходимо воспользоваться полученным суффиксным
	деревом для решения своего варианта задания.\\
	Алфавит строк: строчные буквы латинского алфавита (т.е., от a до z).
	
	\textbf{Вариант 4: Линеаризация циклической строки}\\
	Линеаризовать циклическую строку, то есть найти минимальный в
	лексикографическом смысле разрез циклической строки.\\
	Входные данные: некий разрез циклической строки.\\
	Выходные данные: минимальный в лексикографическом смысле разрез.
	
	\subsection*{Метод решения}
	
В отличие от четвертой лабораторной сейчас перед нами стоит немного другая задача:
если раньше нам приходил/и паттерн/ы и мы искали его/их в тексте, то сейчас нам нужен
алгоритм, в котором мы можем взять текст, как-то его обработать $O(n)$, где $n$ – длина
текста, а потом запустить функцию поиска для паттерна за $O(m)$, где $m$ – длина паттерна. В
итоге мы решим поставленную задачу за $O(n+m)$. Такой алгоритм есть. Именно он
использует структуру данных “Суффиксное дерево”.

Суффиксное дерево – это $compact trie$, который построен по всем суффиксам текущей
строки, начиная от несобственного суффикса и заканчивая суффиксом, состоящем из одной
буквы, обладающий следующими свойствами:
\begin{itemize}
	\item в нем должно быть такое же количество листьев, как и символов в нашей строке (как и
	суффиксов в нашей строке)
	\item  этот $trie$ должен быть сжатый – если есть внутренняя вершина, то у нее должно быть как
	минимум два потомка
	\item не может быть такого, что из 1 вершины выходят два ребра, помеченных строками,
	начинающимися на одну и ту же букву
\end{itemize}
Суффиксное дерево можно построить наивным образом за $O(n^2)$, где $n$ – длина текста.
Достаточно просто поочередно вставлять все суффиксы строки. Действительно, пусть есть
строка $a_1a_2a_3\ldots a_n$. Тогда, чтобы построить суффиксное дерево, мы должны поочередно
вставлять $a_1a_2a_3\ldots a_n$, $\quad a_2a_3\ldots a_n$,$ \quad \ldots$ ,$\quad a_{n-1}a_n$, $ \quad a_n$ символов, что в итоге даст $n + {n-1} + \ldots 3 + 2 + 1$ = $O(n^2)$
по сложности. Очевидно, что это не самый быстрый способ. Чтобы строить суффиксное
дерево максимально быстро – за линейную сложность – существует алгоритм Укконена, в
котором есть 3 важных правила:
\begin{itemize}
	\item добавляем в лист – дописать букву на ребро
	\item  нет пути – создать новый лист
	\item есть строка – ничего не делаем
\end{itemize}
А также присутствуют некоторые важные эвристики, которые ускоряют алгоритм: вместо
строк мы на ребрах храним две интовые переменные, обозначающие начало и конец
текста на ребре, при этом используя глобальную переменную $end$ и инкрементируя ее на
каждой итерации. Помимо этого, есть такое понятие, как суффиксная ссылка, которая перемещает нас из строки вида $x\alpha$ к строке $\alpha$, где $x$ - символ, а $\alpha$ - строка в уже построенном суффиксном дереве, и, так называемые, прыжки по счетчику, которые помогают нам при переходе
между ребрами не проверять несколько символов и перешагивать по ним. Именно все эти
эвристики и правила делают алгоритм Укконена единственно верным выбором, если
перед нам нужно решить задачу при помощи суффиксного дерева.
	
	\subsection*{Описание программы}
	Для реализации алгоритма Укконена я создал класс $TSuffixTree$.
	
	\inputminted[breaklines]{C++}{../src/SuffTree.h}
	
	Реализацию функций, описанных выше, я поместил в отдельный файл.
	
	\inputminted[breaklines]{C++}{../src/SuffTree.cpp}
	
	\inputminted[breaklines]{C++}{../src/main.cpp}
	
	\subsection*{Дневник отладки}
	
	Проблемы в лабораторной были связаны, в основном, непосредственно с алгоритмом
	Укконена. Из-за некорректного построения суффиксного дерева функция минимального
	разреза на больших тестах давала неправильные ответы, однако это было исправлено, и
	теперь программа работает корректно.

	\subsection*{Тест производительности}
	Сравним написанную программу с наивным поиском минимального лексикографического среза: для того, чтобы найти минимальный лексикографический срез, удвоим строку, затем найдем минимум из всех подстрок длины $n$, начинающихся с позиции $start = 0, 1, 2, \ldots n - 1$. Этот наивный алгоритм будет работать за время $O(n^2)$, так как на каждой итерации $start$ мы ищем подстроку длины $n$, что занимает $O(n)$ времени.

	Для сравнения я сгенерировал тесты с различной длиной строки. Очевидно, что на коротких строках будет выигрывать наивная реализация, так как построение суффиксного дерева хоть и линейно, но имеет большую константу. Поэтому я генерировал тесты, в которых длина строки экспоненциально растет с каждым тестом.
	
	\begin{tikzpicture}% coordinates
		\begin{axis}[
			xlabel= x (N is $10^x$),
			ylabel= $\log T$,
			ymin = 0,
			grid=major,
			legend pos=outer north east
			]
			\legend{Solution, Natieve}
			\addplot coordinates {(1, 4.79480162927435) (2, 5.60556145204035) (3, 6.77322215373551) (4, 7.69731765776576) (5, 8.76739374084953) (6, 9.78405053123225)};
			\addplot coordinates {(1, 4.63508143601087) (2, 4.80805559874081) (3, 5.41609605012396) (4, 6.70348294142952) (5, 8.51767935492798) (6, 10.6766194406061)};
		\end{axis}
	\end{tikzpicture}
	\subsection*{Выводы}
	Суффиксное дерево довольно мощная структура данных, имеющая множество приложений в задачах обработки строк. Среди них нахождение включения одной строки в текст, поиск наибольшей общей подстроки для набора строк, и т.д . Так же суффиксное дерево является вспомогательным, например, при построении суффиксных массивов, поиске статистики совпадений и скорее всего где-нибудь еще.
	
	Написание суффиксного дерева мне показалось довольно сложным занятием.
	Мало того, что алгоритм сам по себе не очень простой, но, даже если разобраться на бумаге и начать писать с нуля, то приходишь к выводу, что в этом алгоритме очень много мелких деталей. Неправильно поняв (закодив) одну из них суффиксное дерево отказывается запускаться либо совсем, либо ломается на частных данных.
\end{document}
