\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{minted}
\usepackage{color} %% это для отображения цвета в коде
\usepackage{listings}
\lstset{ %
	language=C++,                 % выбор языка для подсветки (здесь это С++)
	basicstyle=\footnotesize\sffamily, % размер и начертание шрифта для подсветки кода
	numbers=left,               % где поставить нумерацию строк (слева\справа)
	numberstyle=\tiny,           % размер шрифта для номеров строк
	stepnumber=1,                   % размер шага между двумя номерами строк
	numbersep=5pt,                % как далеко отстоят номера строк от подсвечиваемого кода
	backgroundcolor=\color{white}, % цвет фона подсветки - используем \usepackage{color}
	showspaces=false,            % показывать или нет пробелы специальными отступами
	showstringspaces=false,      % показывать или нет пробелы в строках
	showtabs=false,             % показывать или нет табуляцию в строках
	frame=single,              % рисовать рамку вокруг кода
	tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
	captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
	breaklines=true,           % автоматически переносить строки (да\нет)
	breakatwhitespace=false, % переносить строки только если есть пробел
	escapeinside={\%*}{*)}   % если нужно добавить комментарии в коде
}
\usepackage{alltt}
\begin{document}
	
	\section*{Лабораторная работа №\,3 по курсу дискртного анализа: Поиск образца в строке}
	
	Выполнил студент группы М8О-208Б-20 \textit{Ядров Артем}.
	
	\subsection*{Условие}
	
	Кратко описывается задача: 
	\begin{enumerate}
		\item Необходимо реализовать один из стандартных алгоритмов поиска образцов для указанного алфавита.
		\item \textit{Вариант алгоритма:} Поиск одного образца при помощи алгоритма Кнута-Морриса-Пратта.
		\item \textit{Вариант алфавита:} Слова не более 16 знаков латинского алфавита (регистронезависимые).
		\item Запрещается реализовывать алгоритмы на алфавитах меньшей размерности, чем указано в задании. 
	\end{enumerate}
	
	\subsection*{Метод решения}
	
	Алгоритм Кнута-Морисса-Прутта 
	\\Требуется реализовать алгоритм Кнута-Морриса-Пратта для поиска 
	подстроки в строке. Учитывая, что алфавит состоит из регистронезависимых слов не более
	16 знаков, нужно уметь правильно представлять переводы строки, пробелы и табуляции.
	\\ Алгоритм Кнута-Морриса-Пратта прикладывает образец к тексту и начинает делать сравнение
	с левого конца. В случае полного совпадения, было найдено вхождение, слвигаем образец на один символ вправо. Если же есть
	несовпадения, то мы делаем сдвиг по особому правилу, в отличии от алгоритма наивного поиска, который всегда сдвигает на 
	один символ.
	\\Для каждой позиции $i$ определим $sp_i(P)$ как длину наибольшего собственного суффикса $P[1..i]$, который совпадает с префиксом
	$P$, причём символы в позициях $i+1$ и $sp_i(P) + 1$ различны.
	\\ Для каждой позиции $i$ определим $Z_i(P)$ как длину префикса строки $P[i..|P|]$, который совпадает с префиксом $P$. Причем $Z_0(P)$ принято считать равным нулю.
	Набор таких значений называется $Z$-функцией строки $P$. $Z$-функция является известным алгоритмом и может быть вычеслена за линейное время от длины строки.
	\\ Значения $Z_j(P)$ соответствуют такому $sp_i(P)$, что $i = j + Z_j(P) - 1$. Таким образом вычисление всех $sp_i(P)$ имеет сложность $O(n)$, где $n$ - длина образца.
	\\ Будем делать сдвиг, используя вычисленное в каждой позиции значение $sp_i(P)$. Если при сравнении было найдено несовпадение в позиции $i + 1$, то мы можем сделать сдвиг на $i - sp_i(P)$, не теряя вхождений.
	\\ Алгоритм Кнута-Морисса-Пратта сравнивает каждый символ не более двух раз, то есть совершает не более $2*m$ сравнений символов, где $m$ - длина текста. Учитывая вычисление $Z$-функции, сложность алгоритма составит $O(n + m)$.
	
	\subsection*{Описание программы}
	
	Разобьем алгоритм на следующие шаги:
	\begin{enumerate}
		\item Реализация вспомогательных структур и функций
		\item Реализация вычисления $Z$ и $SP$-функции
		\item Реализация алгоритма Кнута-Морисса-Пратта с использованием $SP$-функции
		\item Реализация правильного ввода и поиска подстроки в строке
	\end{enumerate}
	Создадим вспомогательную структуру TWord, которая будет хранить в себе английское слово - символ нашего алфавита, также его номер в строке и номер строки в тексте. Также будем хранить размер слова и его хэш для более быстрой реализации сравнения слов.
	
	\inputminted{C++}{../src/TWord.hpp}
	
	Реализацию функций, описанных выше, я поместил в отдельный файл.
	
	\inputminted{C++}{../src/TWord.cpp}
	 
	И, наконец, в финальном файле содержится ввод и вызов остальных функций. Аккуратно, при просмотре у опытного программиста может случиться инфаркт.
	
	\inputminted{C++}{../src/main.cpp}
	
	Так как мы не можем хранить ВЕСЬ текст, то я решил воспользоваться буффером: хранить текст, превышающий 2 длины шаблона. После того, как буффер заполнится, воспользуемся алгоритмом Кнута-Морисса-Пратта, затем удалим первую половину буффера, при этом запоминая, на каком элементе мы остановились. Также во время чтения вычисляется полиномиальная хэш-функция, которая помогает быстро сравнивать строки.
	
	\subsection*{Дневник отладки}
	Во время реализации я столкнулся с большими проблемами:
	\begin{enumerate}
		\item Проблема с памятью. Изначально я не использовал буффер, а вызывал алгоритм поиска сразу для всего текста, что крайне негативно сказывалось на затрачиваемой памяти.
		\item Проблема со временем.
		\begin{enumerate}
			\item Изначально TWord был классом с закрытыми полями. Поэтому пришлось реализовывать неэффективные по времени методы для работы с данным классом. Чтобы ускорить программу, я решил отказаться от безопасности и сделал класс структурой с открытыми полями.
			\item Также сравнение двух символов алфавита (двух регистронезависисых слов) стоило очень много времени. Изначально я решил сохранять текст в своем первоначальном виде (на случай, если придется дополнительно его выводить куда-либо), поэтому во время сравнения я приводил все символы к верхнему регистру. Это операция, хоть на первый взгляд и не является существенной, вызывается довольно часто. Поэтому я решил сразу приводить к верхнему регистру.
			\item Опять сравнение. Я сравнивал все 16 символов слова, что, естественно, негативно сказывалось на времени. Поэтому я решил добавить поле $Size$ для струкутры $TWord$. Это несколько ускорило операцию сравнения.
			\item Финальное ускорение сравнения. Я решил хранить хэш слова. Конечно, размер тоже является своего рода хэшэм, но он имеет достаточно большое количество колизий. Я решил воспользоваться тривиальным, но эффективным биномиальным хэшэм.
			\item Изначально ввод происходил посимвольно. Посимвольный ввод это достаточно дорогая, как я выяснил позднее, операция. Легче считать построчно, а затем обрабатывать строку, нежели посимвольно считывать текст.
		\end{enumerate}
	\end{enumerate}

	\subsection*{Тест производительности}
	
	Реализованный алгоритм Кнута-Морриса-Пратта с использнованием прфикс функции сравнивается
	с наивным алгоритмом поиска. Замеры производятся на тестах из $10^3$ слов, $10^4$ или $10^5$. 
	Длина образца в первом тесте - 10, во втором - 25, в третьем - 100
	
	\begin{alltt}
		[yadroff@fedora src]$ ./benchmark < tests/03.t
		==============START============
		Naive: 0.822 ms
		KMP: 0.049 ms
		==============END==============
		[yadroff@fedora src]$ ./benchmark < tests/04.t
		==============START============
		Naive: 5.418 ms
		KMP: 0.564 ms
		==============END==============
		[yadroff@fedora src]$ ./benchmark < tests/05.t
		==============START============
		Naive: 25.715 ms
		KMP: 2.412 ms
		==============END==============
	\end{alltt}
	
	Видно, что наивный алгоритм поиска почти на порядок проигрывает алгоритму Кнута-Морриса-Пратта. 
	Классический алгоритм допускает лишние сравнения на этапе поиска образца в тексте, а алгоритм с применение префикс функции - нет.
	Обработка таких сравнений длиться дольше, чем предпроцессинг префикс функции.
	\subsection*{Выводы}
	
	
	Во время выполнения лабораторной работы я изучил алгоритм Кнута-Морриса-Пратта с предпроцессингом через префикс функцию.
	\\Задачи поиска подстроки часто встречаются в жизни, один из очевидных примеров это поиск контента в Интернете по ключевому слову или по ключевой фразе.
	\\Наивный алгоритм поиска нельзя использовать для поиска, т.к. он действует слишком медленно. С другой стороны, КМП не может эффективно находить несколько образцов в тексте, но с этим
	хорошо справляется алгоритм Ахо-Корасика.
\end{document}
