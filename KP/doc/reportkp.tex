\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{minted}
\usepackage{color} %% это для отображения цвета в коде
\usepackage{listings}
\lstset{ %
	language=C++,                 % выбор языка для подсветки (здесь это С++)
	basicstyle=\footnotesize\sffamily, % размер и начертание шрифта для подсветки кода
	numbers=left,               % где поставить нумерацию строк (слева\справа)
	numberstyle=\tiny,           % размер шрифта для номеров строк
	stepnumber=1,                   % размер шага между двумя номерами строк
	numbersep=5pt,                % как далеко отстоят номера строк от подсвечиваемого кода
	backgroundcolor=\color{white}, % цвет фона подсветки - используем \usepackage{color}
	showspaces=false,            % показывать или нет пробелы специальными отступами
	showstringspaces=false,      % показывать или нет пробелы в строках
	showtabs=false,             % показывать или нет табуляцию в строках
	frame=single,              % рисовать рамку вокруг кода
	tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
	captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
	breaklines=true,           % автоматически переносить строки (да\нет)
	breakatwhitespace=false, % переносить строки только если есть пробел
	escapeinside={\%*}{*)}   % если нужно добавить комментарии в коде
}
\usepackage{alltt}
\usepackage{amsmath}
\usepackage{pgfplots}
\pgfplotsset{compat=1.9}

\begin{document}
	
	\section*{Курсовой проект по курсу дискретного анализа: Аудиопоиск}
	
	Выполнил студент группы М8О-308Б-20 \textit{Ядров Артем}.
	
	\subsection*{Условие}
Реализовать систему для поиска аудиозаписи по небольшому отрывку.\newline
Задача состоит в применении быстрого преобразования Фурье для получения из списка частот списка амплитуд. 
Уникальность аудиозаписи дают частоты с максимальными амплитудами. Однако, в диапазон частот может варьироваться от частоты $32.70 Hz$ до $4186.01 Hz$.	 Поэтому необходимо разделить частоты на интервалы.
По максимум частот в каждом интервале можно идентифицировать отрезок аудиозаписи. 
	
	\subsection*{Метод решения}
	Чтобы преобразовать аналоговый сигнал в цифровой используется дискретизация, состоящая из двух этапов: дискретизации по времени и дискретизации по амплитуде.
	
	Дискретизация по времени означает, что сигнал представляется последовательностью отсчетов ($Samples$), взятых через равные промежутки времени.\newline
	Например, если частота дискретизации равна $44100$, то это значит, что сигнал измеряется $441000$ раз в секунду.
	
	Чем больше частота, тем точнее цифровой сигнал соответствует аналоговому. Однако с возрастанием частоты растет и память, необходимая для хранения сигнала, также усложнится процесс обработки за счет увеличения количества операций.
	
	Однако, какую частоту выбрать для того, чтобы цифровой сигнал был достаточно точным и занимал как можно меньше памяти? Нас спасет теорема Котельникова, которая гласит, что для того, чтобы аналоговый (непрерывный по времени)  сигнал можно было восстановить по его отсчетам, частота дискретизации должна быть как минимум вдвое больше максимальной звуковой частоты сигнала.
	
	Так как человек слышит в диапазоне $[20, 20'000] Hz$, то частота дискретизации должна быть минимум $40'000 Hz$.
	
	Сегодня самыми популярными частотами являются $ 44,1 kHz (CD),  48 kHz (DAT)$.
	
	Для получения списка отсчетов мною была использована библиотека $mpg123$. Далее полученный вектор обрабатывается дискретным преобразованием Фурье по частям. В каждой части искался максимум по диапазонам: $0 - 40 Hz, 40 - 80 Hz, 80 - 120 Hz, 120 - 180 Hz, 180 - 300 Hz, 300+ Hz$
	
	Для общего хранения вычислялся хэш, идентифицирующий данный участок аудиозаписи. Хэш хранится в $std::unordered\_map$ в качестве ключа, а в роли значения выступает $std::vector<std::pair>$, в котором хранится $ID$ аудиозаписи и номер блока.
	
	Отмечу, что в силу того, мы последовательно обрабатываем одну аудиозапись, то в рамках одной аудиозаписи все элементы вектора будут отсортированы по времени (номеру блока). Это позволяет использовать бинарный поиск при необходимости.
	
	Для того, чтобы идентифицировать аудиозапись, можно запустить поиск вычисленных хэш-тегов в "базе данных". Однако не всё так просто. Дело в том, что у многих различных фрагментов произведений хэш-теги совпадают. Поэтому если взять отметку $i_1, i_2$ в образце и взять отметки $j_1, j_2$, то наличие двух совпадений будет обусловлено следующим условием:
	
	$Hash(i_1) = Hash(j_1) \: AND \: Hash(i_2) = Hash(j_2)\:AND\:abs(i_1 - j_1) = abs(i_2 - j_2)$.
	
	На великом и могучем это будет звучать так: два фрагмента образца $i_1, i_2$ соответствуют двум фрагментам аудиозаписи $j_1, j_2$ соответственно, если совпадают хэши соответствующих элементов и совпадает временной диапазон в образце и в аудиозаписи.
	
	\subsection*{Исходный код}
	Немного про собственно систему:
	\begin{itemize}
		\item При конструкции объекта происходит чтение базы данных, хранящейся в файле (путь указан в заголовочном файле $Definitions.h$). Если файла не существует, то происходит процесс инициализации базы данных: добавлении всех $.mp3$ файлов в базу. Так как условное количество файлов может быть очень большим, то я распараллелил этот процесс.
		\item Деструктор объекта вызывает запись добавленных в базу аудиозаписей в файл. Если добавлять нечего (отсутствуют новые обработанные аудиозаписи), то, соответственно, ничего не записывается.
		\item Поиск выдает все потенциальные совпадения (если хотя бы один хэш совпал, то аудиозапись попадет в результат), отсортированные по проценту совпадений. Поэтому если поиск выдал неправильный результат, пользователь может найти свою искомую песню среди других песен.
	\end{itemize}	
\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
\inputminted[breaklines]{C++}{../src/Definitions.h}
\vspace{5mm}

	\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
	\inputminted[breaklines]{C++}{../src/Shazam.h}
	\vspace{5mm}
	\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
	
	\inputminted[breaklines]{C++}{../src/Shazam.cpp}
	\vspace{5mm}
	\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
	
	\inputminted[breaklines]{C++}{../src/main.cpp}
	\newpage
	\subsection*{Дневник отладки}

	При реализации чтения/записи базы данных необходимо было убедиться в том, что порядок считывание (запись) происходит в правильном порядке. К сожалению, получилось это не с первого раза.
	
	Во время реализация быстрого преобразования Фурье я наивно предположил,  что корни при рекурсивных вызовах будут совпадать. Однако, на самом деле это не так. Поэтому при первой реализации во время поиска фрагментов процент совпадений был мал, однако после исправления ошибки он и стал похож на правду.
	
	\subsection*{Результаты работы программы}
	
	Для того, чтобы программа создала базу данных, необходимо поместить в папку $LIBRARY$ аудиозаписи. Я поместил туда 3 песни  известной рок-группы $Rammstein$ (также включил туда кавер одной из песен):
	\begin{itemize}
		\item $Deutschland$
		\item $Du\: Hast$
		\item $ Feuer \: Frei$
	\end{itemize} 

	Я решил взять песню $Deutschland$ из другого источника, записать ее фрагмент с помощью микрофона на телефон, а затем попробовать найти ее с помощью $Shazam$.
	
	\bigskip
	Приведу фрагмент вывода, отвечающий за результат поиска.

	\begin{lstlisting}[language=bash]
		search ./Search/DeutschlandPhone.mp3
				SEARCH RESULT:
		5.514% Deutschland-Cover.mp3
		3.06% Rammstein-Deutschland.mp3
		0.1047% Rammstein-FeuerFrei.mp3
		0.06734% Rammstein-DuHast.mp3
		
	\end{lstlisting}
	Примечательно, что записывал я оригинальную версию, но поиск выдал мне кавер. Однако, в оригинальной версии тоже хороший процент совпадений относительно других, поэтому он был бы предложен пользователю в качестве альтернативы.
	
	Теперь попробуем взять разные фрагменты песен и поискать их в базе (более всего мне было интересно, насколько сильно будут отличаться проценты у кавер-версии и оригинала, поэтому для этой песни я взял аж 3 фрагмента).
	\begin{lstlisting}[language=bash]
		search ./Search/DeutschlandFirst.mp3
				SEARCH RESULT:
		53.29% Rammstein-Deutschland.mp3
		40.98% Deutschland-Cover.mp3
		0.8573% Rammstein-FeuerFrei.mp3
		
		search ./Search/DeutschlandSecond.mp3
				SEARCH RESULT:
		21.4% Rammstein-Deutschland.mp3
		16.98% Deutschland-Cover.mp3
		1.084% Rammstein-FeuerFrei.mp3
		0.05004% Rammstein-DuHast.mp3
		
		search ./Search/DeutschlandThird.mp3
				SEARCH RESULT:
		41.99% Rammstein-Deutschland.mp3
		0.3883% Deutschland-Cover.mp3
		0.07765% Rammstein-DuHast.mp3
		0.03883% Rammstein-FeuerFrei.mp3
		
		search ./Search/DuHast.mp3
				SEARCH RESULT:
		23.89% Rammstein-DuHast.mp3
		0.6637% Rammstein-FeuerFrei.mp3
		0.03161% Rammstein-Deutschland.mp3
		0.03161% Deutschland-Cover.mp3
	\end{lstlisting}
	Примечательно, что во время проигрышей оригинал и кавер-версия выдают приблизительно одинаковый процент совпадений (всё же оригинал выигрывает). Однако на третьем фрагменте есть слова, из-за которых кавер так сильно теряет проценты.
	\subsection*{Тест производительности}
	
	Протестируем добавление в базу упомянутых выше аудиозаписей (включая короткие фрагменты).
	
	\begin{tikzpicture}% coordinates
		\begin{axis}[
			xlabel=Size (kB),
			ylabel= T(ns),
			ymin = 0,
			grid=major
			]
			\addplot coordinates {(311.4, 1115533217) (484.4, 761787385) (585.8, 700506738) (650.5, 770041811) (2457.6, 3102428971) (7782.4, 8550003835)  (9728, 10870547717) (13004.8, 14740788834) (13312, 15369237904)  };
		\end{axis}
	\end{tikzpicture}
	\subsection*{Выводы}
	В ходе работы я подробно познакомился с дискретным преобразованием Фурье и алгоритмом быстрого преобразования Фурье (алгоритм Кули-Тьюки), позволяющий вычислять ДПФ за время $O(n\log n)$ вместо $O(n^2)$.
	В качестве прикладного применения преобразование Фурье широко применяется в обработке сигналов, так как оно позволяет перейти от временного представления к частотному.
	
	В ходе работы был создан простейший сервис распознавания музыки. Конечно, он нуждается в сильной доработке: в частности, помимо $GUI$,  требуется создать критерий, согласно которому определять, является ли песня подходящей или нет. В данном случае этим критерием является топ-1 в поиске, но если песни нет в базе данных или она сильно искажена (допустим, моим телефоном), то этот вариант не всегда может быть верным.
\end{document}
